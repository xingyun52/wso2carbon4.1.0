/**
 * Autogenerated by Thrift Compiler (0.8.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef cg_TYPES_H
#define cg_TYPES_H

#include <stdint.h>
#include <Thrift.h>
#include <TApplicationException.h>
#include <protocol/TProtocol.h>
#include <transport/TTransport.h>



namespace cg {

typedef struct _Message__isset {
  _Message__isset() : messageId(false), contentType(false), message(false), soapAction(false), epoch(false), transportHeaders(false), requestURI(false), isDoingREST(false), httpMethod(false), isDoingMTOM(false), isDoingSwA(false) {}
  bool messageId;
  bool contentType;
  bool message;
  bool soapAction;
  bool epoch;
  bool transportHeaders;
  bool requestURI;
  bool isDoingREST;
  bool httpMethod;
  bool isDoingMTOM;
  bool isDoingSwA;
} _Message__isset;

class Message {
 public:

  static const char* ascii_fingerprint; // = "B5678FB3B8E903AC8C11F28055BAB975";
  static const uint8_t binary_fingerprint[16]; // = {0xB5,0x67,0x8F,0xB3,0xB8,0xE9,0x03,0xAC,0x8C,0x11,0xF2,0x80,0x55,0xBA,0xB9,0x75};

  Message() : messageId(""), contentType(""), message(""), soapAction(""), epoch(0), requestURI(""), isDoingREST(0), httpMethod(""), isDoingMTOM(0), isDoingSwA(0) {
  }

  virtual ~Message() throw() {}

  std::string messageId;
  std::string contentType;
  std::string message;
  std::string soapAction;
  int64_t epoch;
  std::map<std::string, std::string>  transportHeaders;
  std::string requestURI;
  bool isDoingREST;
  std::string httpMethod;
  bool isDoingMTOM;
  bool isDoingSwA;

  _Message__isset __isset;

  void __set_messageId(const std::string& val) {
    messageId = val;
  }

  void __set_contentType(const std::string& val) {
    contentType = val;
  }

  void __set_message(const std::string& val) {
    message = val;
  }

  void __set_soapAction(const std::string& val) {
    soapAction = val;
  }

  void __set_epoch(const int64_t val) {
    epoch = val;
  }

  void __set_transportHeaders(const std::map<std::string, std::string> & val) {
    transportHeaders = val;
  }

  void __set_requestURI(const std::string& val) {
    requestURI = val;
  }

  void __set_isDoingREST(const bool val) {
    isDoingREST = val;
  }

  void __set_httpMethod(const std::string& val) {
    httpMethod = val;
  }

  void __set_isDoingMTOM(const bool val) {
    isDoingMTOM = val;
  }

  void __set_isDoingSwA(const bool val) {
    isDoingSwA = val;
  }

  bool operator == (const Message & rhs) const
  {
    if (!(messageId == rhs.messageId))
      return false;
    if (!(contentType == rhs.contentType))
      return false;
    if (!(message == rhs.message))
      return false;
    if (!(soapAction == rhs.soapAction))
      return false;
    if (!(epoch == rhs.epoch))
      return false;
    if (!(transportHeaders == rhs.transportHeaders))
      return false;
    if (!(requestURI == rhs.requestURI))
      return false;
    if (!(isDoingREST == rhs.isDoingREST))
      return false;
    if (!(httpMethod == rhs.httpMethod))
      return false;
    if (!(isDoingMTOM == rhs.isDoingMTOM))
      return false;
    if (!(isDoingSwA == rhs.isDoingSwA))
      return false;
    return true;
  }
  bool operator != (const Message &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Message & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _NotAuthorizedException__isset {
  _NotAuthorizedException__isset() : message(false) {}
  bool message;
} _NotAuthorizedException__isset;

class NotAuthorizedException : public ::apache::thrift::TException {
 public:

  static const char* ascii_fingerprint; // = "EFB929595D312AC8F305D5A794CFEDA1";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xB9,0x29,0x59,0x5D,0x31,0x2A,0xC8,0xF3,0x05,0xD5,0xA7,0x94,0xCF,0xED,0xA1};

  NotAuthorizedException() : message("") {
  }

  virtual ~NotAuthorizedException() throw() {}

  std::string message;

  _NotAuthorizedException__isset __isset;

  void __set_message(const std::string& val) {
    message = val;
  }

  bool operator == (const NotAuthorizedException & rhs) const
  {
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const NotAuthorizedException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NotAuthorizedException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

} // namespace

#endif
